{"version":3,"sources":["../src/fs-plugin.js"],"names":["opts","_analysis","_analysisState","_importAnalysis","analyze","fn","path","state","analysis","skip","undefined","value","analyzers","libFsSource","t","StringLiteral","plugin","pre","visitor","ImportDeclaration","meta","analyzeImportDeclaration","console","log","file","insertBefore","importDeclaration","importDefaultSpecifier","identifier","libFsIdentifier","stringLiteral","AssignmentExpression","write","analyzeAssignmentExpression","replaceWith","awaitExpression","template","type","mapper","filesystemModules","module","expression","CallExpression","read","analyzeCallExpression"],"mappings":";;;;;;kBAMe,UAASA,IAAT,EAAe;AAC5B,MAAIC,kBAAJ;AAAA,MACEC,uBADF;AAAA,MAEEC,kBAAkB,KAFpB;;AAIA,WAASC,OAAT,CAAiBC,EAAjB,EAAqBC,IAArB,EAA2BC,KAA3B,EAAkC;AAChCL,qBAAiB,KAAjB;AACA,QAAMM,WAAWH,GAAGC,IAAH,EAASC,KAAT,CAAjB;AACAD,SAAKG,IAAL;AACA,QAAID,aAAaE,SAAjB,EAA4B;AAC1BT,kBAAYO,SAASG,KAArB;AACAT,uBAAiB,IAAjB;AACD;AACD,QAAIM,aAAa,IAAjB,EAAuBN,iBAAiB,IAAjB;AACxB;;AAED,MAAIU,kBAAJ;AACA;AACA,MAAMC,cAAcC,EAAEC,aAAF,CAAgB,iBAAhB,CAApB;;AAEA,SAAO;AACLC,YAAQ;AACNC,SADM,iBACA;AACJL,oBAAY,qBAAZ;AACD,OAHK;;AAINM,eAAS;AACPC,yBADO,6BACWb,IADX,EACiBC,KADjB,EACwB;AAC7BH,kBAAQQ,UAAUQ,IAAV,CAAeC,wBAAvB,EAAiDf,IAAjD,EAAuDC,KAAvD;AACA,cAAIJ,eAAJ,EAAqB;AACrBmB,kBAAQC,GAAR,CAAYhB,MAAMiB,IAAN,CAAWxB,IAAvB;AACA;;;;;AAKAM,eAAKmB,YAAL,CAAkB,CAChBX,EAAEY,iBAAF,CACE,CACEZ,EAAEa,sBAAF,CACEb,EAAEc,UAAF,CAAarB,MAAMP,IAAN,CAAW6B,eAAxB,CADF,CADF,CADF,EAMEhB,WANF,CADgB,EAShBC,EAAEY,iBAAF,CACE,CAACZ,EAAEa,sBAAF,CAAyBb,EAAEc,UAAF,CAAa,MAAb,CAAzB,CAAD,CADF,EAEEd,EAAEgB,aAAF,CAAgB,MAAhB,CAFF,CATgB,CAAlB;AAcA3B,4BAAkB,IAAlB;AACAG,eAAKG,IAAL;AACD,SA1BM;AA4BPsB,4BA5BO,gCA4BczB,IA5Bd,EA4BoBC,KA5BpB,EA4B2B;AAChCH,kBAAQQ,UAAUoB,KAAV,CAAgBC,2BAAxB,EAAqD3B,IAArD,EAA2DC,KAA3D;AACA,cAAI,CAACL,cAAL,EAAqB;AACrB;;;;;;;;AAQAI,eAAK4B,WAAL,CACEpB,EAAEqB,eAAF,CACEC,SAASnC,UAAUoC,IAAnB,IACEC,OAAOrC,UAAUoC,IAAjB,EACE,2BAAMpC,SAAN,CADF,EAEEa,EAAEc,UAAF,CAAarB,MAAMP,IAAN,CAAW6B,eAAxB,CAFF,EAGEf,EAAEgB,aAAF,CACEvB,MAAMP,IAAN,CAAWuC,iBAAX,CAA6BtC,UAAUuC,MAAvC,CADF,CAHF,CADF,EAQEC,UATJ,CADF;AAaD,SApDM;AAsDPC,sBAtDO,0BAsDQpC,IAtDR,EAsDcC,KAtDd,EAsDqB;AAC1BH,kBAAQQ,UAAU+B,IAAV,CAAeC,qBAAvB,EAA8CtC,IAA9C,EAAoDC,KAApD;AACA,cAAI,CAACL,cAAL,EAAqB;AACrB;;;;;;;;AAQAI,eAAK4B,WAAL,CACEpB,EAAEqB,eAAF,CACEC,SAASnC,UAAUoC,IAAnB,IACEC,OAAOrC,UAAUoC,IAAjB,EACE,2BAAMpC,SAAN,CADF,EAEEa,EAAEc,UAAF,CAAarB,MAAMP,IAAN,CAAW6B,eAAxB,CAFF,EAGEf,EAAEgB,aAAF,CACEvB,MAAMP,IAAN,CAAWuC,iBAAX,CAA6BtC,UAAUuC,MAAvC,CADF,CAHF,CADF,EAQEC,UATJ,CADF;AAaD;AA9EM;AAJH;AADH,GAAP;AAuFD,C;;AAjHD;;;;AACA;;IAAYH,M;;AACZ;;IAAYF,Q;;AACZ;;IAAYtB,C;;AACZ","file":"fs-plugin.js","sourcesContent":["import getAnalyzers from \"../../isotropy-ast-analyzer-fs/dist\";\nimport * as mapper from \"./mappers\";\nimport * as template from \"./templates\";\nimport * as t from \"babel-types\";\nimport clean from \"./utils/node-cleaner\";\n\nexport default function(opts) {\n  let _analysis,\n    _analysisState,\n    _importAnalysis = false;\n\n  function analyze(fn, path, state) {\n    _analysisState = false;\n    const analysis = fn(path, state);\n    path.skip();\n    if (analysis !== undefined) {\n      _analysis = analysis.value;\n      _analysisState = true;\n    }\n    if (analysis === true) _analysisState = true;\n  }\n\n  let analyzers;\n  // Specifies the isotropy filesystem library\n  const libFsSource = t.StringLiteral(\"isotropy-lib-fs\");\n\n  return {\n    plugin: {\n      pre() {\n        analyzers = getAnalyzers();\n      },\n      visitor: {\n        ImportDeclaration(path, state) {\n          analyze(analyzers.meta.analyzeImportDeclaration, path, state);\n          if (_importAnalysis) return;\n          console.log(state.file.opts)\n          /*\n          Inserts two statements:\n            * isotropy fs lib module import\n            * path module import\n          */\n          path.insertBefore([\n            t.importDeclaration(\n              [\n                t.importDefaultSpecifier(\n                  t.identifier(state.opts.libFsIdentifier)\n                )\n              ],\n              libFsSource\n            ),\n            t.importDeclaration(\n              [t.importDefaultSpecifier(t.identifier(\"path\"))],\n              t.stringLiteral(\"path\")\n            )\n          ]);\n          _importAnalysis = true;\n          path.skip;\n        },\n\n        AssignmentExpression(path, state) {\n          analyze(analyzers.write.analyzeAssignmentExpression, path, state);\n          if (!_analysisState) return;\n          /*\n          Based  on  the  analysis  from  the  analyzer  module  (_analysis),\n          the appropriate code translation is created by calling the template\n          with the corresponding mapper function which is inturn fed with the\n          result  of  the  analysis (the first argument). This  code  is  then\n          turned  into  an  await  expr.  The  mapper  function  also  takes\n          the  libFsIdentifier  variable  and  the  basePath  from the  config\n          */\n          path.replaceWith(\n            t.awaitExpression(\n              template[_analysis.type]()(\n                mapper[_analysis.type](\n                  clean(_analysis),\n                  t.identifier(state.opts.libFsIdentifier),\n                  t.stringLiteral(\n                    state.opts.filesystemModules[_analysis.module]\n                  )\n                )\n              ).expression\n            )\n          );\n        },\n\n        CallExpression(path, state) {\n          analyze(analyzers.read.analyzeCallExpression, path, state);\n          if (!_analysisState) return;\n          /*\n          Based  on  the  analysis  from  the  analyzer  module  (_analysis),\n          the appropriate code translation is created by calling the template\n          with the corresponding mapper function which is inturn fed with the\n          result  of  the  analysis (the first argument). This  code  is  then\n          turned  into  an  await  expr.  The  mapper  function  also  takes\n          the  libFsIdentifier  variable  and  the  basePath  from the  config\n          */\n          path.replaceWith(\n            t.awaitExpression(\n              template[_analysis.type]()(\n                mapper[_analysis.type](\n                  clean(_analysis),\n                  t.identifier(state.opts.libFsIdentifier),\n                  t.stringLiteral(\n                    state.opts.filesystemModules[_analysis.module]\n                  )\n                )\n              ).expression\n            )\n          );\n        }\n      }\n    }\n  };\n}\n"]}