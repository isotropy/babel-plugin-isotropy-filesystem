"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sequence = sequence;
exports.concat = concat;
exports.every = every;
exports.exit = exit;
exports.exitAfter = exitAfter;
exports.find = find;
exports.filter = filter;
exports.first = first;
exports.includes = includes;
exports.last = last;
exports.map = map;
exports.reduce = reduce;
exports.reverse = reverse;
exports.slice = slice;
exports.some = some;
exports.sort = sort;
exports.toArray = toArray;
class Seq {

  static of(list) {
    return Array.isArray(list) ? new Seq(sequence(list)) : list instanceof Seq ? list : new Seq(list);
  }

  constructor(seq) {
    this.seq = seq;
  }

  *[Symbol.iterator]() {
    for (const i of this.seq()) {
      yield i;
    }
  }

  concat(seq) {
    return new Seq(concat(this.seq, Array.isArray(seq) ? sequence(seq) : seq instanceof Seq ? seq.seq : seq));
  }

  every(fn) {
    return every(this.seq, fn);
  }

  exit(fn, result) {
    return new Seq(exit(this.seq, fn, result));
  }

  exitAfter(fn, result) {
    return new Seq(exitAfter(this.seq, fn, result));
  }

  filter(fn) {
    return new Seq(filter(this.seq, fn));
  }

  find(fn) {
    return find(this.seq, fn);
  }

  first(predicate) {
    return first(this.seq, predicate);
  }

  includes(item) {
    return includes(this.seq, item);
  }

  last(predicate) {
    return last(this.seq, predicate);
  }

  map(fn) {
    return new Seq(map(this.seq, fn));
  }

  reduce(fn, initialValue, fnShortCircuit) {
    return reduce(this.seq, fn, initialValue, fnShortCircuit);
  }

  reverse() {
    return new Seq(reverse(this.seq));
  }

  slice(begin, end) {
    return new Seq(slice(this.seq, begin, end));
  }

  some(fn) {
    return some(this.seq, fn);
  }

  sort(fn) {
    return new Seq(sort(this.seq, fn));
  }

  toArray() {
    return toArray(this.seq);
  }
}

exports.Seq = Seq;
function sequence(list) {
  return function* gen() {
    for (const item of list) {
      yield item;
    }
  };
}

function concat(seq, newSeq) {
  return function* () {
    for (const i of seq()) {
      yield i;
    }
    for (const j of newSeq()) {
      yield j;
    }
  };
}

function every(seq, fn) {
  let i = 0;
  for (const item of seq()) {
    if (!fn(item, i, seq)) {
      return false;
    }
    i++;
  }
  return true;
}

function exit(seq, fn, result) {
  return function* () {
    let i = 0;
    for (const item of seq()) {
      if (fn(item, i, seq)) {
        return result;
      }
      yield item;
      i++;
    }
  };
}

function exitAfter(seq, fn, result) {
  return function* () {
    let i = 0;
    for (const item of seq()) {
      if (fn(item, i, seq)) {
        yield item;
        return result;
      }
      yield item;
      i++;
    }
  };
}

function find(seq, fn) {
  let i = 0;
  for (const item of seq()) {
    if (fn(item, i, seq)) {
      return item;
    }
    i++;
  }
}

function filter(seq, fn) {
  return function* () {
    let i = 0;
    for (const item of seq()) {
      if (fn(item, i, seq)) {
        yield item;
      }
      i++;
    }
  };
}

function first(_seq, predicate) {
  const seq = predicate ? filter(_seq, predicate) : _seq;

  for (const item of seq()) {
    return item;
  }
}

function includes(seq, what) {
  return some(seq, function (item) {
    return item === what;
  });
}

function last(_seq, predicate) {
  const seq = predicate ? filter(_seq, predicate) : _seq;

  let prev;
  for (const item of seq()) {
    prev = item;
  }
  return prev;
}

function map(seq, fn) {
  return function* () {
    let i = 0;
    for (const item of seq()) {
      yield fn(item, i, seq);
      i++;
    }
  };
}

function reduce(seq, fn, initialValue, fnShortCircuit) {
  let acc = initialValue;
  let i = 0;
  for (const item of seq()) {
    acc = fn(acc, item, i, seq);
    if (fnShortCircuit && fnShortCircuit(acc, item, i, seq)) {
      return acc;
    }
    i++;
  }
  return acc;
}

function reverse(seq) {
  return function* () {
    const all = toArray(seq).reverse();
    for (const item of all) {
      yield item;
    }
  };
}

function slice(seq, begin, end) {
  return function* () {
    let i = 0;
    for (const item of seq()) {
      if (i >= begin && (!end || i < end)) {
        yield item;
      }
      i++;
      if (i === end) {
        return;
      }
    }
  };
}

function some(seq, fn) {
  let i = 0;
  for (const item of seq()) {
    if (fn(item, i, seq)) {
      return true;
    }
    i++;
  }
  return false;
}

function sort(seq, fn) {
  return function* () {
    const all = toArray(seq).sort(fn);
    for (const item of all) {
      yield item;
    }
  };
}

function toArray(seq) {
  const results = [];
  for (const item of seq()) {
    results.push(item);
  }
  return results;
}
//# sourceMappingURL=lazily.js.map