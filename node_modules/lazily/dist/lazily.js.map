{"version":3,"sources":["../src/lazily.js"],"names":["sequence","concat","every","exit","exitAfter","find","filter","first","includes","last","map","reduce","reverse","slice","some","sort","toArray","Seq","of","list","Array","isArray","constructor","seq","Symbol","iterator","i","fn","result","predicate","item","initialValue","fnShortCircuit","begin","end","gen","newSeq","j","_seq","what","prev","acc","all","results","push"],"mappings":"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","file":"lazily.js","sourcesContent":["/* @flow */\ntype PredicateType<T> = (val: T, i?: number, seq?: SequenceFnType<T>) => boolean;\n\nexport class Seq<T> {\n  seq: SequenceFnType<T>;\n\n  static of<T>(list: Array<T> | Seq<T> | SequenceFnType<T>) {\n    return Array.isArray(list)\n      ? new Seq(sequence(list))\n      : list instanceof Seq ? list : new Seq(list);\n  }\n\n  constructor(seq: SequenceFnType<T>) {\n    this.seq = seq;\n  }\n\n  *[Symbol.iterator](): Iterable<T> {\n    for (const i of this.seq()) {\n      yield i;\n    }\n  }\n\n  concat(seq: Array<T> | Seq<T> | SequenceFnType<T>): Seq<T> {\n    return new Seq(\n      concat(this.seq, Array.isArray(seq) ? sequence(seq) : seq instanceof Seq ? seq.seq : seq)\n    );\n  }\n\n  every(fn: PredicateType<T>): boolean {\n    return every(this.seq, fn);\n  }\n\n  exit(fn: PredicateType<T>, result?: any): Seq<T> {\n    return new Seq(exit(this.seq, fn, result));\n  }\n\n  exitAfter(fn: PredicateType<T>, result?: any): Seq<T> {\n    return new Seq(exitAfter(this.seq, fn, result));\n  }\n\n  filter(fn: PredicateType<T>): Seq<T> {\n    return new Seq(filter(this.seq, fn));\n  }\n\n  find(fn: PredicateType<T>): ?T {\n    return find(this.seq, fn);\n  }\n\n  first(predicate: PredicateType<T>): ?T {\n    return first(this.seq, predicate);\n  }\n\n  includes(item: T): boolean {\n    return includes(this.seq, item);\n  }\n\n  last(predicate: PredicateType<T>): ?T {\n    return last(this.seq, predicate);\n  }\n\n  map<TOut>(fn: (val: T, i: number, seq: SequenceFnType<T>) => TOut): Seq<TOut> {\n    return new Seq(map(this.seq, fn));\n  }\n\n  reduce<TAcc>(\n    fn: (acc: TAcc, item: T, i?: number, seq?: SequenceFnType<T>) => TAcc,\n    initialValue: TAcc,\n    fnShortCircuit?: (acc: TAcc, item?: T, i?: number, seq?: SequenceFnType<T>) => boolean\n  ): TAcc {\n    return reduce(this.seq, fn, initialValue, fnShortCircuit);\n  }\n\n  reverse(): Seq<T> {\n    return new Seq(reverse(this.seq));\n  }\n\n  slice(begin: number, end?: number): Seq<T> {\n    return new Seq(slice(this.seq, begin, end));\n  }\n\n  some(fn: PredicateType<T>): boolean {\n    return some(this.seq, fn);\n  }\n\n  sort(fn: (a: T, b: T) => number): Seq<T> {\n    return new Seq(sort(this.seq, fn));\n  }\n\n  toArray(): Array<T> {\n    return toArray(this.seq);\n  }\n}\n\ntype SequenceFnType<T> = () => Generator<T, void, void>;\n\nexport function sequence<T>(list: Iterable<T>): SequenceFnType<T> {\n  return function* gen() {\n    for (const item of list) {\n      yield item;\n    }\n  };\n}\n\nexport function concat<T>(\n  seq: SequenceFnType<T>,\n  newSeq: SequenceFnType<T>\n): SequenceFnType<T> {\n  return function*() {\n    for (const i of seq()) {\n      yield i;\n    }\n    for (const j of newSeq()) {\n      yield j;\n    }\n  };\n}\n\nexport function every<T>(seq: SequenceFnType<T>, fn: PredicateType<T>): boolean {\n  let i = 0;\n  for (const item of seq()) {\n    if (!fn(item, i, seq)) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n}\n\nexport function exit<T>(\n  seq: SequenceFnType<T>,\n  fn: PredicateType<T>,\n  result?: any\n): SequenceFnType<T> {\n  return function*() {\n    let i = 0;\n    for (const item of seq()) {\n      if (fn(item, i, seq)) {\n        return result;\n      }\n      yield item;\n      i++;\n    }\n  };\n}\n\nexport function exitAfter<T>(\n  seq: SequenceFnType<T>,\n  fn: PredicateType<T>,\n  result?: any\n): SequenceFnType<T> {\n  return function*() {\n    let i = 0;\n    for (const item of seq()) {\n      if (fn(item, i, seq)) {\n        yield item;\n        return result;\n      }\n      yield item;\n      i++;\n    }\n  };\n}\n\nexport function find<T>(seq: SequenceFnType<T>, fn: PredicateType<T>): ?T {\n  let i = 0;\n  for (const item of seq()) {\n    if (fn(item, i, seq)) {\n      return item;\n    }\n    i++;\n  }\n}\n\nexport function filter<T>(seq: SequenceFnType<T>, fn: PredicateType<T>): SequenceFnType<T> {\n  return function*() {\n    let i = 0;\n    for (const item of seq()) {\n      if (fn(item, i, seq)) {\n        yield item;\n      }\n      i++;\n    }\n  };\n}\n\nexport function first<T>(_seq: SequenceFnType<T>, predicate: PredicateType<T>): ?T {\n  const seq = predicate ? filter(_seq, predicate) : _seq;\n\n  for (const item of seq()) {\n    return item;\n  }\n}\n\nexport function includes<T>(seq: SequenceFnType<T>, what: T): boolean {\n  return some(seq, item => item === what);\n}\n\nexport function last<T>(_seq: SequenceFnType<T>, predicate: PredicateType<T>): ?T {\n  const seq = predicate ? filter(_seq, predicate) : _seq;\n\n  let prev;\n  for (const item of seq()) {\n    prev = item;\n  }\n  return prev;\n}\n\nexport function map<T, TOut>(\n  seq: SequenceFnType<T>,\n  fn: (val: T, i: number, seq: SequenceFnType<T>) => TOut\n): SequenceFnType<TOut> {\n  return function*() {\n    let i = 0;\n    for (const item of seq()) {\n      yield fn(item, i, seq);\n      i++;\n    }\n  };\n}\n\nexport function reduce<T, TAcc>(\n  seq: SequenceFnType<T>,\n  fn: (acc: TAcc, item: T, i: number, seq: SequenceFnType<T>) => TAcc,\n  initialValue: TAcc,\n  fnShortCircuit?: (acc: TAcc, item?: T, i?: number, seq?: SequenceFnType<T>) => boolean\n): TAcc {\n  let acc = initialValue;\n  let i = 0;\n  for (const item of seq()) {\n    acc = fn(acc, item, i, seq);\n    if (fnShortCircuit && fnShortCircuit(acc, item, i, seq)) {\n      return acc;\n    }\n    i++;\n  }\n  return acc;\n}\n\nexport function reverse<T>(seq: SequenceFnType<T>): SequenceFnType<T> {\n  return function*() {\n    const all = toArray(seq).reverse();\n    for (const item of all) {\n      yield item;\n    }\n  };\n}\n\nexport function slice<T>(\n  seq: SequenceFnType<T>,\n  begin: number,\n  end?: number\n): SequenceFnType<T> {\n  return function*() {\n    let i = 0;\n    for (const item of seq()) {\n      if (i >= begin && (!end || i < end)) {\n        yield item;\n      }\n      i++;\n      if (i === end) {\n        return;\n      }\n    }\n  };\n}\n\nexport function some<T>(seq: SequenceFnType<T>, fn: PredicateType<T>): boolean {\n  let i = 0;\n  for (const item of seq()) {\n    if (fn(item, i, seq)) {\n      return true;\n    }\n    i++;\n  }\n  return false;\n}\n\nexport function sort<T>(seq: SequenceFnType<T>, fn: (a: T, b: T) => number): SequenceFnType<T> {\n  return function*() {\n    const all = toArray(seq).sort(fn);\n    for (const item of all) {\n      yield item;\n    }\n  };\n}\n\nexport function toArray<T>(seq: SequenceFnType<T>): Array<T> {\n  const results = [];\n  for (const item of seq()) {\n    results.push(item);\n  }\n  return results;\n}\n"]}