{"version":3,"sources":["../src/parse.js"],"names":["source","schema","parse","getSchemaAndParser","obj","key","parents","parentKeys","_context","context","params","reuseContext","result","build","output","normalize","src","SchemaClass","includes","Function","Array","constructor","Object"],"mappings":";;;;;;kBAgCe,UAASA,MAAT,EAAiB;AAC9B,QAAM,EAAEC,MAAF,EAAUC,KAAV,KAAoBC,mBAAmBH,MAAnB,CAA1B;AACA,SAAO,UAACI,GAAD,EAAMC,MAAM,aAAZ,EAA2BC,UAAU,EAArC,EAAyCC,aAAa,EAAtD;AAAA,WAA6D,UAACC,WAAW,EAAZ,EAAmB;AACrF,YAAMC,UAAUR,OAAOS,MAAP,IAAiBT,OAAOS,MAAP,CAAcC,YAA/B,GAA8CH,QAA9C,GAAyD,EAAzE;AACA,YAAMI,SAASV,MAAMD,MAAN,EAAcG,GAAd,EAAmBC,GAAnB,EAAwBC,OAAxB,EAAiCC,UAAjC,EAA6CE,OAA7C,CAAf;AACA,YAAMI,QAAQZ,OAAOS,MAAP,IAAiBT,OAAOS,MAAP,CAAcG,KAA7C;AACA,aAAOA,QACF,YAAM;AACL,cAAMC,SAASD,MAAMT,GAAN,EAAWC,GAAX,EAAgBC,OAAhB,EAAyBC,UAAzB,EAAqCE,OAArC,EAA8CG,MAA9C,CAAf;AACA,eAAOE,oCACHA,MADG,GAEH,mBAAUA,MAAV,EAAkB,EAAEV,GAAF,EAAOC,GAAP,EAAYC,OAAZ,EAAqBC,UAArB,EAAlB,CAFJ;AAGD,OALD,EADG,GAOHK,MAPJ;AAQD,KAZM;AAAA,GAAP;AAaD,C;;AA/CD;;;;AAEA;;AAEA;;;;AACA;;;;AACA;;;;AACA;;;;AAEA;;;;AAEA,SAAST,kBAAT,CAA4BH,MAA5B,EAAoC;AAClC,WAASe,SAAT,CAAmBC,GAAnB,EAAwBC,WAAxB,EAAqCP,SAAS,EAA9C,EAAkD;AAChD,WAAOM,eAAeC,WAAf,GAA6BD,GAA7B,GAAmC,IAAIC,WAAJ,CAAgBD,GAAhB,EAAqBN,MAArB,CAA1C;AACD;;AAED,SAAOV,8CACL,CAAC,QAAD,EAAW,QAAX,EAAqB,SAArB,EAAgC,QAAhC,EAA0CkB,QAA1C,CAAmD,OAAOlB,MAA1D,CADK,GAEH,EAAEC,QAAQc,UAAUf,MAAV,2BAAV,EAA8CE,0BAA9C,EAFG,GAGHF,6CAAoCA,kBAAkBmB,QAAtD,GACI,EAAElB,QAAQc,UAAUf,MAAV,0BAAV,EAA6CE,yBAA7C,EADJ,GAEIF,0CAAiCA,kBAAkBoB,KAAnD,GACI,EAAEnB,QAAQc,UAAUf,MAAV,uBAAV,EAA0CE,sBAA1C,EADJ,GAEIF,2CAAkCA,OAAOqB,WAAP,KAAuBC,MAAzD,GACI,EAAErB,QAAQc,UAAUf,MAAV,wBAAV,EAA2CE,uBAA3C,EADJ,GAEI,yBAAW,uBAAsB,OAAOF,MAAO,GAA/C,CAThB;AAUD;;AAED","file":"parse.js","sourcesContent":["import exception from \"./exception\";\n\nimport { Result, Match, Empty, Skip, Fault } from \"./results\";\n\nimport arrayParser from \"./parsers/array\";\nimport functionParser from \"./parsers/function\";\nimport primitiveParser from \"./parsers/primitive\";\nimport objectParser from \"./parsers/object\";\n\nimport { ArraySchema, FunctionSchema, PrimitiveSchema, ObjectSchema, Schema } from \"./schemas\";\n\nfunction getSchemaAndParser(source) {\n  function normalize(src, SchemaClass, params = {}) {\n    return src instanceof SchemaClass ? src : new SchemaClass(src, params);\n  }\n\n  return source instanceof PrimitiveSchema ||\n    [\"string\", \"number\", \"boolean\", \"symbol\"].includes(typeof source)\n    ? { schema: normalize(source, PrimitiveSchema), parse: primitiveParser }\n    : source instanceof FunctionSchema || source instanceof Function\n        ? { schema: normalize(source, FunctionSchema), parse: functionParser }\n        : source instanceof ArraySchema || source instanceof Array\n            ? { schema: normalize(source, ArraySchema), parse: arrayParser }\n            : source instanceof ObjectSchema || source.constructor === Object\n                ? { schema: normalize(source, ObjectSchema), parse: objectParser }\n                : exception(`Invalid schema type ${typeof source}.`);\n}\n\n/*\n  EntryEvalFunction vs EvalFunction:\n    EntryEvalFunction allows key, parents, parentKeys to be empty.\n*/\nexport default function(source) {\n  const { schema, parse } = getSchemaAndParser(source);\n  return (obj, key = \"__UNKNOWN__\", parents = [], parentKeys = []) => (_context = {}) => {\n    const context = schema.params && schema.params.reuseContext ? _context : {};\n    const result = parse(schema)(obj, key, parents, parentKeys)(context);\n    const build = schema.params && schema.params.build;\n    return build\n      ? (() => {\n          const output = build(obj, key, parents, parentKeys)(context)(result);\n          return output instanceof Result\n            ? output\n            : new Match(output, { obj, key, parents, parentKeys });\n        })()\n      : result;\n  };\n}\n"]}