{"version":3,"sources":["../../src/operators/composite.js"],"names":["composite","getSchema","schema","paramSelector","schemaSelector","params","selector","Array","isArray","map","item","filter","x","undefined","of","Object","keys","reduce","acc","key","result","length","_paramsList","ownParams","meta","type","paramsList","some","name","concat","schemas","fn","obj","parents","parentKeys","env","merge","state","value","run","rest","context"],"mappings":"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","file":"composite.js","sourcesContent":["/*       */\nimport { Match, Empty, Skip, Fault } from \"../results\";\nimport { Seq } from \"lazily\";\nimport { Schema, ObjectSchema, FunctionSchema } from \"../schemas\";\nimport parse from \"../parse\";\nimport { getParams } from \"./utils\";\n\nfunction getSchema(schema, paramSelector) {\n  const schemaSelector = schema.params && schema.params.selector\n    ? schema.params.selector\n    : \"default\";\n\n  return Array.isArray(schema)\n    ? schema.map(item => getSchema(item, paramSelector)).filter(x => x !== undefined)\n    : schema instanceof Schema\n        ? schemaSelector === paramSelector ? schema : undefined\n        : typeof schema === \"object\"\n            ? Seq.of(Object.keys(schema)).reduce((acc, key) => {\n                const result = getSchema(schema[key], paramSelector);\n                return result !== undefined && Object.keys(result).length > 0\n                  ? { ...acc, [key]: result }\n                  : acc;\n              }, {})\n            : paramSelector === \"default\" ? schema : undefined;\n}\n\nexport function composite(schema, _paramsList, ownParams = {}) {\n  const meta = {\n    type: \"composite\",\n    schema,\n    paramsList: _paramsList,\n    ownParams\n  };\n\n  const paramsList = _paramsList.some(params => !params.name || params.name === \"default\")\n    ? _paramsList\n    : [{ name: \"default\" }].concat(_paramsList);\n\n  const schemas = paramsList.map(\n    params => new ObjectSchema(getSchema(schema, (params && params.name) || \"default\"), params)\n  );\n\n  function fn(obj, key, parents, parentKeys) {\n    return context => {\n      const env = { obj, key, parents, parentKeys };\n\n      function merge(state, result) {\n        return { ...state, ...result.value };\n      }\n\n      return schemas.length\n        ? (function run([schema, ...rest], state) {\n            const result = parse(schema)(obj, key, parents, parentKeys)(context);\n            return result instanceof Match || result instanceof Empty\n              ? rest.length\n                  ? run(rest, result instanceof Match ? merge(state, result) : state)\n                  : new Match(result instanceof Match ? merge(state, result) : state, env, meta)\n              : result;\n          })(schemas, {})\n        : new Empty(env, meta);\n    };\n  }\n\n  return new FunctionSchema(fn, getParams(ownParams), meta);\n}\n"]}