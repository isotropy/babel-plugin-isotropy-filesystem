"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.repeatingItem = repeatingItem;
exports.unorderedItem = unorderedItem;
exports.optionalItem = optionalItem;
exports.array = array;

var _results = require("../results");

var _schemas = require("../schemas");

var _parse = require("../parse");

var _parse2 = _interopRequireDefault(_parse);

var _exception = require("../exception");

var _exception2 = _interopRequireDefault(_exception);

var _utils = require("./utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function toNeedledSchema(schema) {
  return schema instanceof ArrayItem ? schema.fn : regularItem(schema);
} /*       */


class ArrayItem {
  constructor(fn) {
    this.fn = fn;
  }
}

function unwrap(match) {
  return match.value;
}

/*
  Unordered does not change the needle.
  Searching for "1" in
  [1, 4, 4, 4, 4, 5, 6, 67]
            ^needle
  returns [4, 4], with needle moved to 5.
*/

function repeatingItem(_schema, opts = {}) {
  const meta = { type: "repeatingItem", schema: _schema };

  const min = opts.min || 0;
  const max = opts.max;

  const schema = toNeedledSchema(_schema);

  return new ArrayItem(function (needle) {
    return new _schemas.FunctionSchema(function (obj, key, parents, parentKeys) {
      return function (context) {
        function completed(results, needle) {
          return results.length >= min && (!max || results.length <= max) ? new _results.Match({
            result: new _results.Match(results, { obj, key, parents, parentKeys }, meta),
            needle
          }) : new _results.Match({
            result: new _results.Skip("Incorrect number of matches.", { obj, key, parents, parentKeys }, meta)
          });
        }
        return function run(items, results, needle) {
          const { result, needle: updatedNeedle } = unwrap((0, _parse2.default)(schema(needle))(items, key, parents, parentKeys)(context));

          return result instanceof _results.Match || result instanceof _results.Empty ? items.length > needle ? run(items, result instanceof _results.Match ? results.concat([result.value]) : results, updatedNeedle) : completed(result instanceof _results.Match ? results.concat([result.value]) : results, needle) : result instanceof _results.Skip ? completed(results, needle) : new _results.Match({ result, needle }); //Fault
        }(obj, [], needle);
      };
    }, {}, meta);
  });
}

/*
  Unordered does not change the needle.
  Searching for "1" in
  [1, 2, 4, 5, 6, 67]
         ^needle
  returns 1, with needle still pointing at 4.
  We don't care about the needle.
*/
function unorderedItem(_schema) {
  const meta = { type: "unorderedItem", schema: _schema };

  const schema = toNeedledSchema(_schema);
  return new ArrayItem(function (needle) {
    return new _schemas.FunctionSchema(function (obj, key, parents, parentKeys) {
      return function (context) {
        return function run(items, i) {
          const { result } = unwrap((0, _parse2.default)(schema(i))(items, key, parents, parentKeys)(context));

          return result instanceof _results.Match || result instanceof _results.Empty || result instanceof _results.Fault ? new _results.Match({ result, needle }) : items.length > i ? run(items, i + 1) : new _results.Match({
            result: new _results.Skip(`Unordered item was not found.`, { obj, key, parents, parentKeys }, meta),
            needle
          });
        }(obj, 0);
      };
    }, {}, meta);
  });
}

/*
  Optional items may or may not exist.
  A Skip() is not issued when an item is not found.
  The needle is incremented by 1 if found, otherwise it remains the same.
*/
function optionalItem(_schema) {
  const meta = { type: "optionalItem", schema: _schema };
  const schema = toNeedledSchema(_schema);

  return new ArrayItem(function (needle) {
    return new _schemas.FunctionSchema(function (obj, key, parents, parentKeys) {
      return function (context) {
        const { result } = unwrap((0, _parse2.default)(schema(needle))(obj, key, parents, parentKeys)(context));

        return result instanceof _results.Match || result instanceof _results.Empty ? new _results.Match({ result, needle: needle + 1 }) : result instanceof _results.Skip ? new _results.Match({
          result: new _results.Empty({ obj, key, parents, parentKeys }, meta),
          needle
        }) : new _results.Match({ result, needle });
      };
    }, {}, meta);
  });
}

/*
  Not array types, viz optional, unordered or repeating.
*/
function regularItem(schema) {
  const meta = { type: "regularItem", schema };

  return function (needle) {
    return new _schemas.FunctionSchema(function (obj, key, parents, parentKeys) {
      return function (context) {
        const result = (0, _parse2.default)(schema)(obj[needle], `${key}.${needle}`, parents.concat(obj), parentKeys.concat(key))(context);

        return result instanceof _results.Match || result instanceof _results.Empty ? new _results.Match({ result, needle: needle + 1 }) : new _results.Match({ result, needle });
      };
    }, {}, meta);
  };
}

function array(schemas, params) {
  const meta = { type: "array", schemas, params };

  function fn(obj, key, parents, parentKeys) {
    return function (context) {
      return Array.isArray(obj) ? function run(list, results, needle) {
        const schema = toNeedledSchema(list[0]);
        const { result, needle: updatedNeedle } = unwrap((0, _parse2.default)(schema(needle))(obj, key, parents, parentKeys)(context));

        return result instanceof _results.Skip || result instanceof _results.Fault ? result.updateEnv({ needle }) : result instanceof _results.Match || result instanceof _results.Empty ? list.length > 1 ? run(list.slice(1), results.concat(result instanceof _results.Empty ? [] : [result.value]), updatedNeedle) : new _results.Match(result instanceof _results.Match ? results.concat(result.value) : results, { obj, key, parents, parentKeys }, meta) : (0, _exception2.default)("Unknown result type.");
      }(schemas, [], 0) : new _results.Fault(`Expected array but got ${typeof obj}.`, { obj, key, parents, parentKeys }, meta);
    };
  }
  return new _schemas.FunctionSchema(fn, (0, _utils.getParams)(params), { name: "array" });
}
//# sourceMappingURL=array.js.map