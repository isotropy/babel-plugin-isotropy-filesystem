{"version":3,"sources":["../../src/operators/array.js"],"names":["repeatingItem","unorderedItem","optionalItem","array","toNeedledSchema","schema","ArrayItem","fn","regularItem","constructor","unwrap","match","value","_schema","opts","meta","type","min","max","obj","key","parents","parentKeys","completed","results","needle","length","result","run","items","updatedNeedle","context","concat","i","schemas","params","Array","isArray","list","updateEnv","slice","name"],"mappings":"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","file":"array.js","sourcesContent":["/*       */\nimport { Result, Match, Empty, Skip, Fault } from \"../results\";\nimport { Schema, FunctionSchema } from \"../schemas\";\nimport parse from \"../parse\";\nimport exception from \"../exception\";\nimport { getParams } from \"./utils\";\n\nfunction toNeedledSchema(schema) {\n  return schema instanceof ArrayItem ? schema.fn : regularItem(schema);\n}\n\nclass ArrayItem {\n  constructor(fn) {\n    this.fn = fn;\n  }\n}\n\nfunction unwrap(match) {\n  return match.value;\n}\n\n/*\n  Unordered does not change the needle.\n  Searching for \"1\" in\n  [1, 4, 4, 4, 4, 5, 6, 67]\n            ^needle\n  returns [4, 4], with needle moved to 5.\n*/\n\nexport function repeatingItem(_schema, opts = {}) {\n  const meta = { type: \"repeatingItem\", schema: _schema };\n\n  const min = opts.min || 0;\n  const max = opts.max;\n\n  const schema = toNeedledSchema(_schema);\n\n  return new ArrayItem(\n    needle =>\n      new FunctionSchema(\n        (obj, key, parents, parentKeys) => context => {\n          function completed(results, needle) {\n            return results.length >= min && (!max || results.length <= max)\n              ? new Match({\n                  result: new Match(results, { obj, key, parents, parentKeys }, meta),\n                  needle\n                })\n              : new Match({\n                  result: new Skip(\n                    \"Incorrect number of matches.\",\n                    { obj, key, parents, parentKeys },\n                    meta\n                  )\n                });\n          }\n          return (function run(items, results, needle) {\n            const { result, needle: updatedNeedle } = unwrap(\n              parse(schema(needle))(items, key, parents, parentKeys)(context)\n            );\n\n            return result instanceof Match || result instanceof Empty\n              ? items.length > needle\n                  ? run(\n                      items,\n                      result instanceof Match ? results.concat([result.value]) : results,\n                      updatedNeedle\n                    )\n                  : completed(\n                      result instanceof Match ? results.concat([result.value]) : results,\n                      needle\n                    )\n              : result instanceof Skip\n                  ? completed(results, needle)\n                  : new Match({ result, needle }); //Fault\n          })(obj, [], needle);\n        },\n        {},\n        meta\n      )\n  );\n}\n\n/*\n  Unordered does not change the needle.\n  Searching for \"1\" in\n  [1, 2, 4, 5, 6, 67]\n         ^needle\n  returns 1, with needle still pointing at 4.\n  We don't care about the needle.\n*/\nexport function unorderedItem(_schema) {\n  const meta = { type: \"unorderedItem\", schema: _schema };\n\n  const schema = toNeedledSchema(_schema);\n  return new ArrayItem(needle => {\n    return new FunctionSchema(\n      (obj, key, parents, parentKeys) => context =>\n        (function run(items, i) {\n          const { result } = unwrap(parse(schema(i))(items, key, parents, parentKeys)(context));\n\n          return result instanceof Match || result instanceof Empty || result instanceof Fault\n            ? new Match({ result, needle })\n            : items.length > i\n                ? run(items, i + 1)\n                : new Match({\n                    result: new Skip(\n                      `Unordered item was not found.`,\n                      { obj, key, parents, parentKeys },\n                      meta\n                    ),\n                    needle\n                  });\n        })(obj, 0),\n      {},\n      meta\n    );\n  });\n}\n\n/*\n  Optional items may or may not exist.\n  A Skip() is not issued when an item is not found.\n  The needle is incremented by 1 if found, otherwise it remains the same.\n*/\nexport function optionalItem(_schema) {\n  const meta = { type: \"optionalItem\", schema: _schema };\n  const schema = toNeedledSchema(_schema);\n\n  return new ArrayItem(needle => {\n    return new FunctionSchema(\n      (obj, key, parents, parentKeys) => context => {\n        const { result } = unwrap(\n          parse(schema(needle))(obj, key, parents, parentKeys)(context)\n        );\n\n        return result instanceof Match || result instanceof Empty\n          ? new Match({ result, needle: needle + 1 })\n          : result instanceof Skip\n              ? new Match({\n                  result: new Empty({ obj, key, parents, parentKeys }, meta),\n                  needle\n                })\n              : new Match({ result, needle });\n      },\n      {},\n      meta\n    );\n  });\n}\n\n/*\n  Not array types, viz optional, unordered or repeating.\n*/\nfunction regularItem(schema) {\n  const meta = { type: \"regularItem\", schema };\n\n  return needle =>\n    new FunctionSchema(\n      (obj, key, parents, parentKeys) => context => {\n        const result = parse(schema)(\n          obj[needle],\n          `${key}.${needle}`,\n          parents.concat(obj),\n          parentKeys.concat(key)\n        )(context);\n\n        return result instanceof Match || result instanceof Empty\n          ? new Match({ result, needle: needle + 1 })\n          : new Match({ result, needle });\n      },\n      {},\n      meta\n    );\n}\n\nexport function array(schemas, params) {\n  const meta = { type: \"array\", schemas, params };\n\n  function fn(obj, key, parents, parentKeys) {\n    return context =>\n      Array.isArray(obj)\n        ? (function run(list, results, needle) {\n            const schema = toNeedledSchema(list[0]);\n            const { result, needle: updatedNeedle } = unwrap(\n              parse(schema(needle))(obj, key, parents, parentKeys)(context)\n            );\n\n            return result instanceof Skip || result instanceof Fault\n              ? result.updateEnv({ needle })\n              : result instanceof Match || result instanceof Empty\n                  ? list.length > 1\n                      ? run(\n                          list.slice(1),\n                          results.concat(result instanceof Empty ? [] : [result.value]),\n                          updatedNeedle\n                        )\n                      : new Match(\n                          result instanceof Match ? results.concat(result.value) : results,\n                          { obj, key, parents, parentKeys },\n                          meta\n                        )\n                  : exception(\"Unknown result type.\");\n          })(schemas, [], 0)\n        : new Fault(\n            `Expected array but got ${typeof obj}.`,\n            { obj, key, parents, parentKeys },\n            meta\n          );\n  }\n  return new FunctionSchema(fn, getParams(params), { name: \"array\" });\n}\n"]}