"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; /*       */


exports.capture = capture;
exports.captureIf = captureIf;
exports.modify = modify;
exports.captureAndParse = captureAndParse;
exports.literal = literal;
exports.take = take;

var _results = require("../results");

var _schemas = require("../schemas");

var _parse = require("../parse");

var _parse2 = _interopRequireDefault(_parse);

var _utils = require("./utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function capture(params) {
  return captureIf(function (obj) {
    return typeof obj !== "undefined";
  }, params);
}

function captureIf(predicate, params) {
  return take(predicate, undefined, params);
}

function modify(predicate, modifier, params) {
  return take(predicate, undefined, params, { modifier });
}

function captureAndParse(schema, params) {
  return take(function (obj) {
    return typeof obj !== "undefined";
  }, schema, params);
}

function literal(what, params) {
  return take(function (x) {
    return x === what;
  }, undefined, params, {
    skipMessage: function skipMessage(x) {
      return `Expected value to be ${what.toString()} but got ${x.toString()}.`;
    }
  });
}

function take(predicate, schema, params = {}, options = {}) {
  const meta = { type: "take", schema, params, predicate, options };

  function fn(obj, key, parents, parentKeys) {
    return function (context) {
      return predicate(obj) ? typeof schema !== "undefined" ? function () {
        const result = (0, _parse2.default)(schema)(obj, key, parents, parentKeys)(context);

        return result instanceof _results.Match ? new _results.Match(_extends({}, obj, result.value), { obj, key, parents, parentKeys }, meta) : result instanceof _results.Empty ? new _results.Match(_extends({}, obj), { obj, key, parents, parentKeys }, meta) : result instanceof _results.Skip ? new _results.Skip("Capture failed in inner schema.", { obj, key, parents, parentKeys }, meta) : result; //Fault
      }() : new _results.Match(options.modifier ? options.modifier(obj) : obj, { obj, key, parents, parentKeys }, meta) : new _results.Skip(options.skipMessage ? options.skipMessage(obj) : `Predicate returned false. Predicate was ${predicate.toString()}`, { obj, key, parents, parentKeys }, meta);
    };
  }

  return new _schemas.FunctionSchema(fn, (0, _utils.getParams)(params), meta);
}
//# sourceMappingURL=capture.js.map