"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; /*       */


exports.default = function (schema) {
  return function (_obj, key, parents, parentKeys) {
    return function (context) {
      const obj = schema.params && schema.params.modifiers && schema.params.modifiers.object ? schema.params.modifiers.object(_obj) : _obj;

      return typeof obj !== "undefined" ? function () {
        const contextOrFail = _lazily.Seq.of(Object.keys(schema.value)).sort(function (a, b) {
          return sortFn(schema.value[a], schema.value[b]);
        }).reduce(function (context, childKey) {
          const childSource = schema.value[childKey];

          const childUnmodified = childSource.params && childSource.params.unmodified || {
            object: false,
            property: false
          };

          const effectiveContainerObj = childUnmodified.object ? _obj : obj;
          const propModifier = schema.params && schema.params.modifiers && schema.params.modifiers.property;

          const childItem = !childUnmodified.property && propModifier ? propModifier(effectiveContainerObj, childKey) : effectiveContainerObj[childKey];

          // child is { ... }
          const isChildLiteralObject = typeof childSource === "object" && childSource.constructor === Object;

          const childSchema = (0, _literals.wrapSchemaIfLiteralChild)(schema, childSource);

          const result = (0, _parse2.default)(childSchema)(childItem, childKey, parents.concat(obj), parentKeys.concat(key))(context);

          return result instanceof _results.Match ? childSchema.params && childSchema.params.replace || isChildLiteralObject ? _extends({}, context, result.value) : _extends({}, context, {
            [childSchema.params && childSchema.params.key || childKey]: result.value
          }) : result instanceof _results.Empty ? context : result;
        }, context, function (acc, item) {
          return acc instanceof _results.Skip || acc instanceof _results.Fault;
        });

        return contextOrFail instanceof _results.Skip || contextOrFail instanceof _results.Fault ? contextOrFail : typeof contextOrFail !== "undefined" && contextOrFail !== context ? new _results.Match(contextOrFail, { obj, key, parents, parentKeys }) : new _results.Empty({ obj, key, parents, parentKeys });
      }() : new _results.Skip(`Cannot parse undefined.`, { obj, key, parents, parentKeys });
    };
  };
};

var _lazily = require("lazily");

var _results = require("../results");

var _parse = require("../parse");

var _parse2 = _interopRequireDefault(_parse);

var _schemas = require("../schemas");

var _literals = require("./literals");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function sortFn(schema1, schema2) {
  const schema1Order = schema1.params && schema1.params.order ? schema1.params.order : 0;
  const schema2Order = schema2.params && schema2.params.order ? schema2.params.order : 0;
  return schema1Order - schema2Order;
}
//# sourceMappingURL=object.js.map