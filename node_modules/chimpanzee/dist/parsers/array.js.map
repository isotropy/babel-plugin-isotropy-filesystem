{"version":3,"sources":["../../src/parsers/array.js"],"names":["schema","obj","key","parents","parentKeys","Array","isArray","value","length","results","of","reduce","acc","childSource","i","childSchema","result","concat","context","item","last","slice","resultArr","filter","r","map","modifyResult","params","build","output"],"mappings":";;;;;;kBAOe,UAASA,MAAT,EAAiB;AAC9B,SAAO,UAACC,GAAD,EAAMC,GAAN,EAAWC,OAAX,EAAoBC,UAApB;AAAA,WAAmC,mBAAW;AACnD,aAAOC,MAAMC,OAAN,CAAcL,GAAd,IACHD,OAAOO,KAAP,CAAaC,MAAb,KAAwBP,IAAIO,MAA5B,GACI,kBAAU,4BAA2BR,OAAOO,KAAP,CAAaC,MAAO,YAAWP,IAAIO,MAAO,GAA/E,EAAmF;AACjFP,WADiF;AAEjFC,WAFiF;AAGjFC,eAHiF;AAIjFC;AAJiF,OAAnF,CADJ,GAOK,YAAM;AACL,cAAMK,UAAU,YAAIC,EAAJ,CAAOV,OAAOO,KAAd,EAAqBI,MAArB,CACd,UAACC,GAAD,EAAMC,WAAN,EAAmBC,CAAnB,EAAyB;AACvB,gBAAMC,cAAc,wCAAyBf,MAAzB,EAAiCa,WAAjC,CAApB;;AAEA,gBAAMG,SAAS,qBAAMD,WAAN,EACbd,IAAIa,CAAJ,CADa,EAEZ,GAAEZ,GAAI,IAAGY,CAAE,EAFC,EAGbX,QAAQc,MAAR,CAAehB,GAAf,CAHa,EAIbG,WAAWa,MAAX,CAAkBf,GAAlB,CAJa,EAKbgB,OALa,CAAf;;AAOA,iBAAOF,mCAA0BA,gCAA1B,GACHA,MADG,GAEHJ,IAAIK,MAAJ,CAAWD,MAAX,CAFJ;AAGD,SAda,EAed,EAfc,EAgBd,UAACJ,GAAD,EAAMO,IAAN;AAAA,iBAAeP,gCAAuBA,6BAAtC;AAAA,SAhBc,CAAhB;;AAmBA,cAAMQ,OAAOX,QAAQY,KAAR,CAAc,CAAC,CAAf,EAAkB,CAAlB,CAAb;;AAEA,eAAOD,iCAAwBA,8BAAxB,GACHA,IADG,GAEF,YAAM;AACL,gBAAME,YAAYb,QAAQc,MAAR,CAAe;AAAA,mBAAKC,2BAAL;AAAA,WAAf,EAAwCC,GAAxC,CAA4C;AAAA,mBAAKD,EAAEjB,KAAP;AAAA,WAA5C,CAAlB;AACA,gBAAMmB,eAAe1B,OAAO2B,MAAP,CAAcC,KAAnC;AACA,iBAAOF,eACF,YAAM;AACL,kBAAMG,SAASH,aAAaJ,SAAb,CAAf;AACA,mBAAOO,oCACHA,MADG,GAEH,mBAAUA,MAAV,EAAkB,EAAE5B,GAAF,EAAOC,GAAP,EAAYC,OAAZ,EAAqBC,UAArB,EAAlB,CAFJ;AAGD,WALD,EADG,GAOHkB,UAAUd,MAAV,GACI,mBAAUc,SAAV,EAAqB,EAAErB,GAAF,EAAOC,GAAP,EAAYC,OAAZ,EAAqBC,UAArB,EAArB,CADJ,GAEI,mBAAU,EAAEH,GAAF,EAAOC,GAAP,EAAYC,OAAZ,EAAqBC,UAArB,EAAV,CATR;AAUD,SAbD,EAFJ;AAgBD,OAtCD,EARD,GA+CH,kBAAU,iDAAV,EAA4D;AAC1DH,WAD0D;AAE1DC,WAF0D;AAG1DC,eAH0D;AAI1DC;AAJ0D,OAA5D,CA/CJ;AAqDD,KAtDM;AAAA,GAAP;AAuDD,C;;AA9DD;;AACA;;AACA;;;;AACA;;AACA","file":"array.js","sourcesContent":["/*       */\nimport { Seq } from \"lazily\";\nimport { Result, Match, Empty, Skip, Fault } from \"../results\";\nimport parse from \"../parse\";\nimport { ArraySchema } from \"../schemas\";\nimport { wrapSchemaIfLiteralChild } from \"./literals\";\n\nexport default function(schema) {\n  return (obj, key, parents, parentKeys) => context => {\n    return Array.isArray(obj)\n      ? schema.value.length !== obj.length\n          ? new Skip(`Expected array of length ${schema.value.length} but got ${obj.length}.`, {\n              obj,\n              key,\n              parents,\n              parentKeys\n            })\n          : (() => {\n              const results = Seq.of(schema.value).reduce(\n                (acc, childSource, i) => {\n                  const childSchema = wrapSchemaIfLiteralChild(schema, childSource);\n\n                  const result = parse(childSchema)(\n                    obj[i],\n                    `${key}.${i}`,\n                    parents.concat(obj),\n                    parentKeys.concat(key)\n                  )(context);\n\n                  return result instanceof Skip || result instanceof Fault\n                    ? result\n                    : acc.concat(result);\n                },\n                [],\n                (acc, item) => acc instanceof Skip || acc instanceof Fault\n              );\n\n              const last = results.slice(-1)[0];\n\n              return last instanceof Skip || last instanceof Fault\n                ? last\n                : (() => {\n                    const resultArr = results.filter(r => r instanceof Match).map(r => r.value);\n                    const modifyResult = schema.params.build;\n                    return modifyResult\n                      ? (() => {\n                          const output = modifyResult(resultArr);\n                          return output instanceof Result\n                            ? output\n                            : new Match(output, { obj, key, parents, parentKeys });\n                        })()\n                      : resultArr.length\n                          ? new Match(resultArr, { obj, key, parents, parentKeys })\n                          : new Empty({ obj, key, parents, parentKeys });\n                  })();\n            })()\n      : new Skip(`Schema is an array but property is a non-array.`, {\n          obj,\n          key,\n          parents,\n          parentKeys\n        });\n  };\n}\n"]}